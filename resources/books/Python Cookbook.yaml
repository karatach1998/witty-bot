---
title: Python Cookbook
location:
  type: gdrive
  file_id: "1SvkQMYxPXcc8RZJ_aw1ADb1fXIKIawIV"
parts:
- title: Chapter 1. Data Structures and Algorithms
  start: 18
  end: 53
  chapters:
  - title: 1.1. Unpacking a Sequence into Separate Variables
    start: 18
    end: 19
  - title: 1.2. Unpacking Elements from Iterables of Arbitrary Length
    start: 20
    end: 21
  - title: 1.3. Keeping the Last N Items
    start: 22
    end: 23
  - title: 1.4. Finding the Largest or Smallest N Items
    start: 24
    end: 24
  - title: 1.5. Implementing a Priority Queue
    start: 25
    end: 27
  - title: 1.6. Mapping Keys to Multiple Values in a Dictionary
    start: 28
    end: 28
  - title: 1.7. Keeping Dictionaries in Order
    start: 29
    end: 29
  - title: 1.8. Calculating with Dictionaries
    start: 30
    end: 31
  - title: 1.9. Finding Commonalities in Two Dictionaries
    start: 32
    end: 33
  - title: 1.10. Removing Duplicates from a Sequence while Maintaining Order
    start: 34
    end: 34
  - title: 1.11. Naming a Slice
    start: 35
    end: 36
  - title: 1.12. Determining the Most Frequently Occurring Items in a Sequence
    start: 37
    end: 37
  - title: 1.13. Sorting a List of Dictionaries by a Common Key
    start: 38
    end: 39
  - title: 1.14. Sorting Objects Without Native Comparison Support
    start: 40
    end: 40
  - title: 1.15. Grouping Records Together Based on a Field
    start: 41
    end: 42
  - title: 1.16. Filtering Sequence Elements
    start: 43
    end: 44
  - title: 1.17. Extracting a Subset of a Dictionary
    start: 45
    end: 45
  - title: 1.18. Mapping Names to Sequence Elements
    start: 46
    end: 48
  - title: 1.19. Transforming and Reducing Data at the Same Time
    start: 49
    end: 49
  - title: 1.20. Combining Multiple Mappings into a Single Mapping
    start: 50
    end: 53
- title: Chapter 2. Strings and Text
  start: 54
  end: 99
  chapters:
  - title: 2.1. Splitting Strings on Any of Multiple Delimiters
    start: 54
    end: 54
  - title: 2.2. Matching Text at the Start or End of a String
    start: 55
    end: 56
  - title: 2.3. Matching Strings Using Shell Wildcard Patterns
    start: 57
    end: 58
  - title: 2.4. Matching and Searching for Text Patterns
    start: 59
    end: 61
  - title: 2.5. Searching and Replacing Text
    start: 62
    end: 62
  - title: 2.6. Searching and Replacing Case-Insensitive Text
    start: 63
    end: 63
  - title: 2.7. Specifying a Regular Expression for the Shortest Match
    start: 64
    end: 64
  - title: 2.8. Writing a Regular Expression for Multiline Patterns
    start: 65
    end: 66
  - title: 2.9. Normalizing Unicode Text to a Standard Representation
    start: 67
    end: 68
  - title: 2.10. Working with Unicode Characters in Regular Expressions
    start: 69
    end: 69
  - title: 2.11. Stripping Unwanted Characters from Strings
    start: 70
    end: 70
  - title: 2.12. Sanitizing and Cleaning Up Text
    start: 71
    end: 73
  - title: 2.13. Aligning Text Strings
    start: 74
    end: 74
  - title: 2.14. Combining and Concatenating Strings
    start: 75
    end: 77
  - title: 2.15. Interpolating Variables in Strings
    start: 78
    end: 80
  - title: 2.16. Reformatting Text to a Fixed Number of Columns
    start: 81
    end: 81
  - title: 2.17. Handling HTML and XML Entities in Text
    start: 82
    end: 82
  - title: 2.18. Tokenizing Text
    start: 83
    end: 85
  - title: 2.19. Writing a Simple Recursive Descent Parser
    start: 86
    end: 94
  - title: 2.20. Performing Text Operations on Byte Strings
    start: 95
    end: 99
- title: Chapter 3. Numbers, Dates, and Times
  start: 100
  end: 129
  chapters:
  - title: 3.1. Rounding Numerical Values
    start: 100
    end: 100
  - title: 3.2. Performing Accurate Decimal Calculations
    start: 101
    end: 103
  - title: 3.3. Formatting Numbers for Output
    start: 104
    end: 105
  - title: 3.4. Working with Binary, Octal, and Hexadecimal Integers
    start: 106
    end: 106
  - title: 3.5. Packing and Unpacking Large Integers from Bytes
    start: 107
    end: 108
  - title: 3.6. Performing Complex-Valued Math
    start: 109
    end: 110
  - title: 3.7. Working with Infinity and NaNs
    start: 111
    end: 112
  - title: 3.8. Calculating with Fractions
    start: 113
    end: 113
  - title: 3.9. Calculating with Large Numerical Arrays
    start: 114
    end: 116
  - title: 3.10. Performing Matrix and Linear Algebra Calculations
    start: 117
    end: 118
  - title: 3.11. Picking Things at Random
    start: 119
    end: 120
  - title: 3.12. Converting Days to Seconds, and Other Basic Time Conversions
    start: 121
    end: 122
  - title: 3.13. Determining Last Friday’s Date
    start: 123
    end: 123
  - title: 3.14. Finding the Date Range for the Current Month
    start: 124
    end: 125
  - title: 3.15. Converting Strings into Datetimes
    start: 126
    end: 126
  - title: 3.16. Manipulating Dates Involving Time Zones
    start: 127
    end: 129
- title: Chapter 4. Iterators and Generators
  start: 130
  end: 157
  chapters:
  - title: 4.1. Manually Consuming an Iterator
    start: 130
    end: 130
  - title: 4.2. Delegating Iteration
    start: 131
    end: 131
  - title: 4.3. Creating New Iteration Patterns with Generators
    start: 132
    end: 133
  - title: 4.4. Implementing the Iterator Protocol
    start: 134
    end: 135
  - title: 4.5. Iterating in Reverse
    start: 136
    end: 136
  - title: 4.6. Defining Generator Functions with Extra State
    start: 137
    end: 138
  - title: 4.7. Taking a Slice of an Iterator
    start: 139
    end: 139
  - title: 4.8. Skipping the First Part of an Iterable
    start: 140
    end: 141
  - title: 4.9. Iterating Over All Possible Combinations or Permutations
    start: 142
    end: 143
  - title: 4.10. Iterating Over the Index-Value Pairs of a Sequence
    start: 144
    end: 145
  - title: 4.11. Iterating Over Multiple Sequences Simultaneously
    start: 146
    end: 147
  - title: 4.12. Iterating on Items in Separate Containers
    start: 148
    end: 148
  - title: 4.13. Creating Data Processing Pipelines
    start: 149
    end: 151
  - title: 4.14. Flattening a Nested Sequence
    start: 152
    end: 152
  - title: 4.15. Iterating in Sorted Order Over Merged Sorted Iterables
    start: 153
    end: 154
  - title: 4.16. Replacing Infinite while Loops with an Iterator
    start: 155
    end: 157
- title: Chapter 5. Files and I/O
  start: 158
  end: 191
  chapters:
  - title: 5.1. Reading and Writing Text Data
    start: 158
    end: 160
  - title: 5.2. Printing to a File
    start: 161
    end: 160
  - title: 5.3. Printing with a Different Separator or Line Ending
    start: 161
    end: 161
  - title: 5.4. Reading and Writing Binary Data
    start: 162
    end: 163
  - title: 5.5. Writing to a File That Doesn’t Already Exist
    start: 164
    end: 164
  - title: 5.6. Performing I/O Operations on a String
    start: 165
    end: 165
  - title: 5.7. Reading and Writing Compressed Datafiles
    start: 166
    end: 167
  - title: 5.8. Iterating Over Fixed-Sized Records
    start: 168
    end: 168
  - title: 5.9. Reading Binary Data into a Mutable Buffer
    start: 169
    end: 169
  - title: 5.10. Memory Mapping Binary Files
    start: 170
    end: 172
  - title: 5.11. Manipulating Pathnames
    start: 173
    end: 173
  - title: 5.12. Testing for the Existence of a File
    start: 174
    end: 174
  - title: 5.13. Getting a Directory Listing
    start: 175
    end: 176
  - title: 5.14. Bypassing Filename Encoding
    start: 177
    end: 177
  - title: 5.15. Printing Bad Filenames
    start: 178
    end: 179
  - title: 5.16. Adding or Changing the Encoding of an Already Open File
    start: 180
    end: 181
  - title: 5.17. Writing Bytes to a Text File
    start: 182
    end: 182
  - title: 5.18. Wrapping an Existing File Descriptor As a File Object
    start: 183
    end: 183
  - title: 5.19. Making Temporary Files and Directories
    start: 184
    end: 186
  - title: 5.20. Communicating with Serial Ports
    start: 187
    end: 187
  - title: 5.21. Serializing Python Objects
    start: 188
    end: 191
- title: Chapter 6. Data Encoding and Processing
  start: 192
  end: 233
  chapters:
  - title: 6.1. Reading and Writing CSV Data
    start: 192
    end: 195
  - title: 6.2. Reading and Writing JSON Data
    start: 196
    end: 199
  - title: 6.3. Parsing Simple XML Data
    start: 200
    end: 202
  - title: 6.4. Parsing Huge XML Files Incrementally
    start: 203
    end: 205
  - title: 6.5. Turning a Dictionary into XML
    start: 206
    end: 207
  - title: 6.6. Parsing, Modifying, and Rewriting XML
    start: 208
    end: 209
  - title: 6.7. Parsing XML Documents with Namespaces
    start: 210
    end: 211
  - title: 6.8. Interacting with a Relational Database
    start: 212
    end: 213
  - title: 6.9. Decoding and Encoding Hexadecimal Digits
    start: 214
    end: 215
  - title: 6.10. Decoding and Encoding Base64
    start: 216
    end: 215
  - title: 6.11. Reading and Writing Binary Arrays of Structures
    start: 216
    end: 219
  - title: 6.12. Reading Nested and Variable-Sized Binary Structures
    start: 220
    end: 230
  - title: 6.13. Summarizing Data and Performing Statistics
    start: 231
    end: 233
- title: Chapter 7. Functions
  start: 234
  end: 259
  chapters:
  - title: 7.1. Writing Functions That Accept Any Number of Arguments
    start: 234
    end: 235
  - title: 7.2. Writing Functions That Only Accept Keyword Arguments
    start: 236
    end: 236
  - title: 7.3. Attaching Informational Metadata to Function Arguments
    start: 237
    end: 237
  - title: 7.4. Returning Multiple Values from a Function
    start: 238
    end: 238
  - title: 7.5. Defining Functions with Default Arguments
    start: 239
    end: 240
  - title: 7.6. Defining Anonymous or Inline Functions
    start: 241
    end: 241
  - title: 7.7. Capturing Variables in Anonymous Functions
    start: 242
    end: 243
  - title: 7.8. Making an N-Argument Callable Work As a Callable with Fewer Arguments
    start: 244
    end: 247
  - title: 7.9. Replacing Single Method Classes with Functions
    start: 248
    end: 248
  - title: 7.10. Carrying Extra State with Callback Functions
    start: 249
    end: 251
  - title: 7.11. Inlining Callback Functions
    start: 252
    end: 254
  - title: 7.12. Accessing Variables Defined Inside a Closure
    start: 255
    end: 259
- title: Chapter 8. Classes and Objects
  start: 260
  end: 345
  chapters:
  - title: 8.1. Changing the String Representation of Instances
    start: 260
    end: 261
  - title: 8.2. Customizing String Formatting
    start: 262
    end: 262
  - title: 8.3. Making Objects Support the Context-Management Protocol
    start: 263
    end: 264
  - title: 8.4. Saving Memory When Creating a Large Number of Instances
    start: 265
    end: 266
  - title: 8.5. Encapsulating Names in a Class
    start: 267
    end: 267
  - title: 8.6. Creating Managed Attributes
    start: 268
    end: 272
  - title: 8.7. Calling a Method on a Parent Class
    start: 273
    end: 276
  - title: 8.8. Extending a Property in a Subclass
    start: 277
    end: 280
  - title: 8.9. Creating a New Kind of Class or Instance Attribute
    start: 281
    end: 283
  - title: 8.10. Using Lazily Computed Properties
    start: 284
    end: 286
  - title: 8.11. Simplifying the Initialization of Data Structures
    start: 287
    end: 290
  - title: 8.12. Defining an Interface or Abstract Base Class
    start: 291
    end: 293
  - title: 8.13. Implementing a Data Model or Type System
    start: 294
    end: 299
  - title: 8.14. Implementing Custom Containers
    start: 300
    end: 303
  - title: 8.15. Delegating Attribute Access
    start: 304
    end: 307
  - title: 8.16. Defining More Than One Constructor in a Class
    start: 308
    end: 309
  - title: 8.17. Creating an Instance Without Invoking init
    start: 310
    end: 310
  - title: 8.18. Extending Classes with Mixins
    start: 311
    end: 315
  - title: 8.19. Implementing Stateful Objects or State Machines
    start: 316
    end: 321
  - title: 8.20. Calling a Method on an Object Given the Name As a String
    start: 322
    end: 322
  - title: 8.21. Implementing the Visitor Pattern
    start: 323
    end: 327
  - title: 8.22. Implementing the Visitor Pattern Without Recursion
    start: 328
    end: 333
  - title: 8.23. Managing Memory in Cyclic Data Structures
    start: 334
    end: 337
  - title: 8.24. Making Classes Support Comparison Operations
    start: 338
    end: 339
  - title: 8.25. Creating Cached Instances
    start: 340
    end: 345
- title: Chapter 9. Metaprogramming
  start: 346
  end: 413
  chapters:
  - title: 9.1. Putting a Wrapper Around a Function
    start: 346
    end: 347
  - title: 9.2. Preserving Function Metadata When Writing Decorators
    start: 348
    end: 349
  - title: 9.3. Unwrapping a Decorator
    start: 350
    end: 350
  - title: 9.4. Defining a Decorator That Takes Arguments
    start: 351
    end: 352
  - title: 9.5. Defining a Decorator with User Adjustable Attributes
    start: 353
    end: 355
  - title: 9.6. Defining a Decorator That Takes an Optional Argument
    start: 356
    end: 357
  - title: 9.7. Enforcing Type Checking on a Function Using a Decorator
    start: 358
    end: 361
  - title: 9.8. Defining Decorators As Part of a Class
    start: 362
    end: 363
  - title: 9.9. Defining Decorators As Classes
    start: 364
    end: 366
  - title: 9.10. Applying Decorators to Class and Static Methods
    start: 367
    end: 368
  - title: 9.11. Writing Decorators That Add Arguments to Wrapped Functions
    start: 369
    end: 371
  - title: 9.12. Using Decorators to Patch Class Definitions
    start: 372
    end: 372
  - title: 9.13. Using a Metaclass to Control Instance Creation
    start: 373
    end: 375
  - title: 9.14. Capturing Class Attribute Definition Order
    start: 376
    end: 378
  - title: 9.15. Defining a Metaclass That Takes Optional Arguments
    start: 379
    end: 380
  - title: 9.16. Enforcing an Argument Signature on *args and **kwargs
    start: 381
    end: 383
  - title: 9.17. Enforcing Coding Conventions in Classes
    start: 384
    end: 386
  - title: 9.18. Defining Classes Programmatically
    start: 387
    end: 390
  - title: 9.19. Initializing Class Members at Definition Time
    start: 391
    end: 392
  - title: 9.20. Implementing Multiple Dispatch with Function Annotations
    start: 393
    end: 398
  - title: 9.21. Avoiding Repetitive Property Methods
    start: 399
    end: 400
  - title: 9.22. Defining Context Managers the Easy Way
    start: 401
    end: 402
  - title: 9.23. Executing Code with Local Side Effects
    start: 403
    end: 404
  - title: 9.24. Parsing and Analyzing Python Source
    start: 405
    end: 408
  - title: 9.25. Disassembling Python Byte Code
    start: 409
    end: 413
- title: Chapter 10. Modules and Packages
  start: 414
  end: 453
  chapters:
  - title: 10.1. Making a Hierarchical Package of Modules
    start: 414
    end: 414
  - title: 10.2. Controlling the Import of Everything
    start: 415
    end: 415
  - title: 10.3. Importing Package Submodules Using Relative Names
    start: 416
    end: 417
  - title: 10.4. Splitting a Module into Multiple Files
    start: 418
    end: 420
  - title: 10.5. Making Separate Directories of Code Import Under a Common Namespace
    start: 421
    end: 422
  - title: 10.6. Reloading Modules
    start: 423
    end: 423
  - title: 10.7. Making a Directory or Zip File Runnable As a Main Script
    start: 424
    end: 424
  - title: 10.8. Reading Datafiles Within a Package
    start: 425
    end: 425
  - title: 10.9. Adding Directories to sys.path
    start: 426
    end: 427
  - title: 10.10. Importing Modules Using a Name Given in a String
    start: 428
    end: 428
  - title: 10.11. Loading Modules from a Remote Machine Using Import Hooks
    start: 429
    end: 444
  - title: 10.12. Patching Modules on Import
    start: 445
    end: 447
  - title: 10.13. Installing Packages Just for Yourself
    start: 448
    end: 448
  - title: 10.14. Creating a New Python Environment
    start: 449
    end: 449
  - title: 10.15. Distributing Packages
    start: 450
    end: 453
- title: Chapter 11. Network and Web Programming
  start: 454
  end: 501
  chapters:
  - title: 11.1. Interacting with HTTP Services As a Client
    start: 454
    end: 457
  - title: 11.2. Creating a TCP Server
    start: 458
    end: 461
  - title: 11.3. Creating a UDP Server
    start: 462
    end: 463
  - title: 11.4. Generating a Range of IP Addresses from a CIDR Address
    start: 464
    end: 465
  - title: 11.5. Creating a Simple REST-Based Interface
    start: 466
    end: 470
  - title: 11.6. Implementing a Simple Remote Procedure Call with XML-RPC
    start: 471
    end: 472
  - title: 11.7. Communicating Simply Between Interpreters
    start: 473
    end: 474
  - title: 11.8. Implementing Remote Procedure Calls
    start: 475
    end: 477
  - title: 11.9. Authenticating Clients Simply
    start: 478
    end: 480
  - title: 11.10. Adding SSL to Network Services
    start: 481
    end: 486
  - title: 11.11. Passing a Socket File Descriptor Between Processes
    start: 487
    end: 491
  - title: 11.12. Understanding Event-Driven I/O
    start: 492
    end: 497
  - title: 11.13. Sending and Receiving Large Arrays
    start: 498
    end: 501
- title: Chapter 12. Concurrency
  start: 502
  end: 555
  chapters:
  - title: 12.1. Starting and Stopping Threads
    start: 502
    end: 504
  - title: 12.2. Determining If a Thread Has Started
    start: 505
    end: 507
  - title: 12.3. Communicating Between Threads
    start: 508
    end: 513
  - title: 12.4. Locking Critical Sections
    start: 514
    end: 516
  - title: 12.5. Locking with Deadlock Avoidance
    start: 517
    end: 520
  - title: 12.6. Storing Thread-Specific State
    start: 521
    end: 521
  - title: 12.7. Creating a Thread Pool
    start: 522
    end: 525
  - title: 12.8. Performing Simple Parallel Programming
    start: 526
    end: 529
  - title: 12.9. Dealing with the GIL (and How to Stop Worrying About It)
    start: 530
    end: 532
  - title: 12.10. Defining an Actor Task
    start: 533
    end: 536
  - title: 12.11. Implementing Publish/Subscribe Messaging
    start: 537
    end: 540
  - title: 12.12. Using Generators As an Alternative to Threads
    start: 541
    end: 547
  - title: 12.13. Polling Multiple Thread Queues
    start: 548
    end: 550
  - title: 12.14. Launching a Daemon Process on Unix
    start: 551
    end: 555
- title: Chapter 13. Utility Scripting and System Administration
  start: 556
  end: 581
  chapters:
  - title: 13.1. Accepting Script Input via Redirection, Pipes, or Input Files
    start: 556
    end: 556
  - title: 13.2. Terminating a Program with an Error Message
    start: 557
    end: 557
  - title: 13.3. Parsing Command-Line Options
    start: 558
    end: 560
  - title: 13.4. Prompting for a Password at Runtime
    start: 561
    end: 561
  - title: 13.5. Getting the Terminal Size
    start: 562
    end: 561
  - title: 13.6. Executing an External Command and Getting Its Output
    start: 562
    end: 563
  - title: 13.7. Copying or Moving Files and Directories
    start: 564
    end: 565
  - title: 13.8. Creating and Unpacking Archives
    start: 566
    end: 566
  - title: 13.9. Finding Files by Name
    start: 567
    end: 568
  - title: 13.10. Reading Configuration Files
    start: 569
    end: 571
  - title: 13.11. Adding Logging to Simple Scripts
    start: 572
    end: 574
  - title: 13.12. Adding Logging to Libraries
    start: 575
    end: 575
  - title: 13.13. Making a Stopwatch Timer
    start: 576
    end: 577
  - title: 13.14. Putting Limits on Memory and CPU Usage
    start: 578
    end: 579
  - title: 13.15. Launching a Web Browser
    start: 580
    end: 581
- title: Chapter 14. Testing, Debugging, and Exceptions
  start: 582
  end: 613
  chapters:
  - title: 14.1. Testing Output Sent to stdout
    start: 582
    end: 583
  - title: 14.2. Patching Objects in Unit Tests
    start: 584
    end: 586
  - title: 14.3. Testing for Exceptional Conditions in Unit Tests
    start: 587
    end: 588
  - title: 14.4. Logging Test Output to a File
    start: 589
    end: 589
  - title: 14.5. Skipping or Anticipating Test Failures
    start: 590
    end: 590
  - title: 14.6. Handling Multiple Exceptions
    start: 591
    end: 592
  - title: 14.7. Catching All Exceptions
    start: 593
    end: 594
  - title: 14.8. Creating Custom Exceptions
    start: 595
    end: 596
  - title: 14.9. Raising an Exception in Response to Another Exception
    start: 597
    end: 598
  - title: 14.10. Reraising the Last Exception
    start: 599
    end: 599
  - title: 14.11. Issuing Warning Messages
    start: 600
    end: 601
  - title: 14.12. Debugging Basic Program Crashes
    start: 602
    end: 603
  - title: 14.13. Profiling and Timing Your Program
    start: 604
    end: 606
  - title: 14.14. Making Your Programs Run Faster
    start: 607
    end: 613
- title: Chapter 15. C Extensions
  start: 614
  end: 681
  chapters:
  - title: 15.1. Accessing C Code Using ctypes
    start: 616
    end: 621
  - title: 15.2. Writing a Simple C Extension Module
    start: 622
    end: 625
  - title: 15.3. Writing an Extension Function That Operates on Arrays
    start: 626
    end: 628
  - title: 15.4. Managing Opaque Pointers in C Extension Modules
    start: 629
    end: 630
  - title: 15.5. Defining and Exporting C APIs from Extension Modules
    start: 631
    end: 635
  - title: 15.6. Calling Python from C
    start: 636
    end: 641
  - title: 15.7. Releasing the GIL in C Extensions
    start: 642
    end: 641
  - title: 15.8. Mixing Threads from C and Python
    start: 642
    end: 643
  - title: 15.9. Wrapping C Code with Swig
    start: 644
    end: 648
  - title: 15.10. Wrapping Existing C Code with Cython
    start: 649
    end: 654
  - title: 15.11. Using Cython to Write High-Performance Array Operations
    start: 655
    end: 659
  - title: 15.12. Turning a Function Pointer into a Callable
    start: 660
    end: 660
  - title: 15.13. Passing NULL-Terminated Strings to C Libraries
    start: 661
    end: 664
  - title: 15.14. Passing Unicode Strings to C Libraries
    start: 665
    end: 669
  - title: 15.15. Converting C Strings to Python
    start: 670
    end: 670
  - title: 15.16. Working with C Strings of Dubious Encoding
    start: 671
    end: 673
  - title: 15.17. Passing Filenames to C Extensions
    start: 674
    end: 674
  - title: 15.18. Passing Open Files to C Extensions
    start: 675
    end: 675
  - title: 15.19. Reading File-Like Objects from C
    start: 676
    end: 678
  - title: 15.20. Consuming an Iterable from C
    start: 679
    end: 679
  - title: 15.21. Diagnosing Segmentation Faults
    start: 680
    end: 681
